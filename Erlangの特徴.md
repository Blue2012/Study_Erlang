# はじめに
皆さんに紹介したい言語がありまして、Erlangという言語です。
SQLの次に好きな領域の話なのですが、  
とても奥深い世界ですので、私もまだまだ、勉強中ではあるのですが、  
本日は少しだけ触りをお伝えできればと思います。

# 関数型言語
まず皆さん、関数型言語って知ってますか？  
この答えを即答するのってなかなか難しそうですが、関数型言語の逆って知ってますか？  

命令型言語です。  

命令型言語とは端的に言うのであれば、「状態を変化させる言語」です。  
例えば、以下のようなJavaのがあります。  

```
public int totalFoodsPrice(List<Item> itemList) {
  int totalPrice = 0;
  for (int i = 0; i < itemList.size(); i++) {
    Item item = itemList.get(i);
    if (Objects.equals(item.getCategory(), "Foods")) {
      totalPrice += item.getPrice();
    }
  }
  return totalPrice;
}
```

上記ですが、変数iは「商品リストの何番目」  
変数totalPriceは「ループで回して取得した金額の合計値」といった形で、  
それぞれ、何番目の何ていう商品でそれらの合計金額はいくらといった状態を表しています。  

こういった命令型言語のなかでも代表的なプログラミングパラダイムなのは「手続き(procedure)型言語」です。  
プロシージャって皆さん、なんとなくどこかで聞いたことないですか？  
「手続き」というのは、ある特定の命令のひとまとまりを示します。  

いっぽうで、関数型言語またの名を宣言型言語といいますが、それは何なのか。

「対象の性質を宣言します」

状態は変化せず、いわゆる「不変の状態」で保持され続けます。

良し悪しはあると思いますが、不変であることの強みとは何なのでしょうか？
以下に例を挙げてみますね。

１．x = 1 です  
２．x = 1 + 3 です  
３．x = 4 です  
４．x = x です  
５．1 = 4 です？  

いずれもすべて、xという値です。  
これら、すべて、x の定義ですが、値は変化します。  
ですが、関数型言語において、一度でも x = 1と定義したら、1です。  
それが4だと命令されたとしても1のままになります。  


このように同じパラメータに対して、常に同じ結果を返すような関数のことを「参照透過」であるといいます。  
式の値を置き換えたとしても、プログラムのふるまいが変わらないことを示します。  

皆さんは「破壊的処理」「非破壊的処理」という言葉を聞いたことがありますでしょうか？  

破壊的処理　→　元のデータを上書きする処理  
非破壊的処理　→　元のデータを残し、別のデータとして新しくデータを残す処理  

そのプログラムに何を求めるかですが、関数型言語においてはデータはとても安定しているといえます。

ちなみに専門用語で、変数の再代入などでプログラムの状態が変化することを「副作用」と呼び、  
副作用を持たない関数のことを「純粋関数」と呼びます。  

例えば、以下のような状態は副作用があるといえます。  

```
x = today() = 2020/10/27  
　-- 1日待つ　--  
x = today() = 2020/10/28  
```

ん？昨日まで「2020/10/27」だった値がいつの間にか、「2020/10/28」に勝手に変化しました…  

では、純粋関数である場合はというと。  

x = add_two_to(3) = 5  

3 + 2 の結果は常に5になるという結果を返します。  
「常に」です。一度、定義したら変わることはないです。


# Erlangのお話
Erlangとは並行処理／分散処理／耐障害性といった特徴を備えた関数型プログラミング言語で、  
スウェーデンの通信機器メーカーであるエリクソン社が開発した言語です。  
過去さかのぼるとこの言語は電話通信網用に利用されていました。  

では、簡単に特徴をお伝えします。  

・軽い  
・並行処理に強い  
・プロセスを分離している  
・耐障害性が高い  
　※エリクソン社の電話通信網は安定しており、耐障害性が高いというのは有名な話です。  
 
なぜ、耐障害性が高いのかといいますと。  
色々と理由はありますが。  

・変数は不変である(代入は一度きり)
・処理を司っているプロセスが死んでも他のプロセスに影響を与えない

単体で見ても大量処理を前提とした安定したつくりをコンセプトとして考えられていることが容易に想像つきますが、  
このErlangには異なるコンピュータ間で分散した複数のプロセスを連携させて動作するためのサポートも組み込みで備えています。  

あと、この後の話でも触れますが、このErlangにはとっておきの奥義が隠されています。


# Erlangのアーキテクチャ
私も勉強中なので、すべてをお伝えできる訳でもないのですが、  
Erlangの処理を支える重要なコンポーネントについて、お伝えしたいと思います。  

Erlangが動作するのはErlangVirtualMachine(BEAM)という仮想マシン（OSの1プロセスとして動作する）上になります。  
これは、有名なJavaVirtalMachineと同じように、OSやCPUの種類に依存せずに、  
Javaのプログラムを動作させることが可能です。  

分かりやすくアーキテクチャを紹介しているページがあるので、そちらも紹介しておきます。  

https://medium.com/elixirlabs/anatomy-of-an-elixir-process-878030c37166  

余談ですが、同じようにErlangVMの上で動作する言語にElixirという言語があります。  
※Rubyを触っていたこともあり、個人的にはこちらのほうが好きです。  

まず、VMの上で動作するため、特定のアーキテクチャに依存することはありません。  
もう一つ、アーキテクチャをお伝えするうえで大事になるのは、アクターモデルという考え方です。  

アクターモデルというのは、並行計算、並行処理、並行コンピューティングに用いられる数学的フレームワークのことです。  
※詳細はWikiを参照のこと。  

![image](https://user-images.githubusercontent.com/18514297/97384611-608f2900-1913-11eb-8d65-9b3772e0dcd6.png)  

Elixirの紹介記事から抜粋したものですが、考え方は同じなので、抜粋して記載します。  

Erlangでは冒頭でお伝えしたように関数形式で一つ一つの処理を定義するのですが、  
それらが実行されて処理の段階に遷移するとプロセスに変わります。  

ErlangとElixirで呼び名が変わってややこしいのですが、プロセス＝アクターです。  
またここで言っている「プロセス」というのは「OSのプロセス」は全く別物であるため、そちらも注意です。  
※先に進むほど(中級者レベル)、ごっちゃになりそうになるので注意です。  

これらのプロセスは独自にかつ、並行してそれぞれの処理を実行します。  
アクターモデルではないプログラムと比較すると何が違うかと言いますと、  
端的に言えば、このプロセスというのはものすごく高速に動作します。  

軽量かつ、高速、並行して、大量のプロセス（処理）を実行できます。  
また、これらのプロセス間で処理を連携することも可能ですが、連携の際に行われる通信は非同期通信となるため、  
どちらか一つのプロセスに処理が依存することはありません。  
かつ、一度、定義（宣言された）処理はどこかで勝手に変わることはありません（Erlangを触れると秒で実感）ので、  
とても安定しているということが言えるかと思います。  

ちなみに各プロセスですが、大別すると以下の処理を行うことが可能です。  

```
プロセスから別のプロセスに対してメッセージを送信する
プロセスからのメッセージを別のプロセスが受信する
プロセスが別のプロセスを生成する
プロセスが別のプロセスをリンクする
プロセスが別のプロセスをモニタする
```

これらの処理を組み合わせることで高速かつ大量の通信処理を安定して実施することが可能になります。  
さすが、通信会社が編み出した技術ですね。  
そもそも、処理数が膨れることを想定し、各処理の影響を最小限にとどめることを前提に考えられており、理にかなっています。  

あと、もう一つ、最後のトピックに移る前にErlangがどういったものに利用されているのかは  
以下の方がご紹介いただいていますので、こちらをご覧ください。  

Erlang はどこで使われているの？  
https://gist.github.com/voluntas/b94b8e090e34da13f1e36bff13ab6320  

端的に言うと、「ネットワークを介して、サーバーと大量通信を安定して動作させる必要がある」の要件を伴うのであれば、  
需要はあるかと思います。  
加えて、この言語は、決まり事がややこしいので、そもそも、ある程度の技術的な下地がないと話を理解できないという特徴があり、  
まだ、日本の中でそれほど、技術を扱える人は少ないのではないでしょうか。（もしかしたら、私が知らないだけで皆、触れる？）

# Nitendo Switchの通知システムに採用されてます
既に世間的には結構有名な話なので、ご存じの方も多いかもしれませんが、  
Switchという任天堂社の家庭用ゲーム機における通知システムに採用されています。  

Switchといえば、世界中から常時とんでもない接続数の通信が同時並行で行われるわけなのですが、  
ものともせず、動作しているわけです。  
この縁の下の力持ちを担っているのがErlangです。  

ちなみにとっておきの奥義というのは「hot code reloading」という機能でして、こちらは何かというと、  
既に動いているデータはそのまま維持して、土台となっているコードを差し替えることができる機能です。  
つまりシステム稼働中に停止させることなく、プログラムの差し替えを行うことが可能です。

Erlangをそこまでかけないのでコードで具体例を出せないのですが、例えば以下のようなことができるということです。  

```
function greet(male：こんにちは!～くん,female：こんにちは！～さん)
greet(male,kenzo) -> "こんにちはkenzoくん" 
```

上記のコードをシステム止めずに以下のように差し替えることができます。

```
function greet(male：ありがとう!～くん,female：さようなら！～さん)
greet(male,kenzo) -> "ありがとう!kenzoくん" 
```

任天堂のSwitchはこの機能を使って、困難を乗り越えたことがあるようですよ。
詳しくは↓の記事に記載されています。

https://speakerdeck.com/elixirfest/otp-to-ejabberd-wohuo-yong-sita-nintendo-switch-tm-xiang-ke-hutusiyutong-zhi-sisutemu-npns-false-kai-fa-shi-li
